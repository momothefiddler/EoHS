this_parses_in_both_wml_and_lua=hackily--{EOHS_LUA_FILE (<<-- training.cfg
-- #textdomain wesnoth-Era_of_High_Sorcery
local getmetatable,ipairs,next,pairs,setmetatable,tonumber,tostring,type,unpack = getmetatable,ipairs,next,pairs,setmetatable,tonumber,tostring,type,unpack
local wesnoth,table,string,math,os,debug,helper,_,EoHS,_G,_ENV = wesnoth,table,string,math,os,debug,EoHS.helper,EoHS._,EoHS,_G,nil

--[[
summon_



TODO: put back the "you didn't pick an alliance" warning
TODO: spell stats on the training screen
TODO: mini-images on the skills screen

ranks of special spells only affect focused study cost,
    since the prereqs are custom
Summon Chimera (R4, each realm 3 points)
Volcano (R6, each realm 5 points?)

unused units, unintentional:
  Elder Mage,Royal Warrior,Troll Hero+,Ancient Lich,Saurian Oracle
  Boat,Galleon
  Cuttle Fish
unused units, intentional:
  Giant Spider (not worth triggering people's arachnophobia),
  drakes(burner+Armageddon,clasher,glider) (I don't like 'em)

  
  ]]

local w111 = wesnoth.compare_versions(wesnoth.game_config.version, ">=", "1.11.0")
  

EoHS.skills = {
  realms = {
    {
      id = "evocation",
      names = {
        realm = _"Evocation",
        skill = _"Evocation skill",
        --practitioner = _"Evoker",
      },
      spells = {
        { "energy_blast", "wizard_sword", "mage_shield", "summon_fire_guardian", "construction", },
        { "corridor_of_frost", "summon_arctic_drake", "dispelling_touch", },
        { "fireball", "group_teleport", "summon_sea_serpent", },
        { "ogre_fury", "circle_of_protection", "haste", },
        { "aegis", "create_portal", "annulling_lance", },
        { "meteor_storm", "call_dragon", "unknown_spell_0", },
      },
    },
    {
      id = "nature_magic",
      names = {
        realm = _"Nature magic",
        skill = _"Nature magic skill",
      },
      spells = {
        { "summon_wolf", "restraint", "summon_giant_scorpion", "mud_touch" },
        { "change_terrain", "mount", "regeneration", "summon_wose", },
        { "summon_water_serpent", "lightning_bolt", "metamorphosis", "dehydration", },
        { "summon_gryphon", "rampage", "expansive_change" },
        { "summon_yeti", "repelling_gust", "restoration", },
        { "swarm_nest", "altar_of_battle", "hurricane", "fissure", },
      },
    },
    {
      id = "necromancy",
      names = {
        realm = _"Necromancy",
        skill = _"Necromancy skill",
      },
      spells = {
        { "curse_of_anxiety", "summon_vampire_bat", "pall_of_fatigue", "black_cat", },
        { "summon_skeleton", "siphon_strength", "poison_ground", "summon_ghost", },
        { "zombie_swarm", "reanimating_touch", "spiritform", "dark_pact", },
        { "soul_bind", "compulsion", "summon_chocobone", },
        { "renounce_life", "vex_dragon_bones", "undying_army", },
        { "zombie_mastery", "zombie_apocalypse", "unknown_spell_3" },
      },
    },
  },
  options = {
    { id="show_unusual", fake_toggle_button=true, name=_"Show unusual skills", description=_"Some skills complicate the game and are intended for experienced EoHS players." },
    { unusual=true, id="focused_study", fake_toggle_button=true, name=_"Focused Study", description=_"You only need to spend one point per spell rank. In exchange, you lose points equal to the highest rank of any spell you know, and your ranged attacks are much weaker." },
  },
  talents = {
    --{ id="efficiency", name=_"Efficient", description=_"Your spells cost 20% less mana/gold." },
    { id="summoner", name=_"Summoner", description=_"You cast summoning spells faster by 2 AP, and summoning rituals faster by 1 turn." },
    { id="enchanter", name=_"Enchanter", description=_"You cast enchantment spells faster by 2 AP, and enchantment rituals faster by 1 turn." },
    { id="farseer", name=_"Farseer", description=_"The range of your spells is doubled. Some spells that affect an area centered on you have their radius doubled." },
    { id="forceful", name=_"Battlemage", description=_"Your attack spells are 50% more powerful, and your summons have +50% damage and hitpoints for one turn." },
    { unusual=true, id="mentor", name=_"Mentor", description=_"You can train one apprentice. Your apprentices can learn spells you know." },
    { unusual=true, id="extra_apprentice_1", name=_"Extra apprentice 1", description=_"You can train up to 2 apprentices." },
    { unusual=true, id="extra_apprentice_2", name=_"Extra apprentice 2", description=_"You can train up to 3 apprentices." },
    { unusual=true, id="greater_mentor", name=_"Worldly mentor", description=_"Your apprentices can learn any spell, not just ones you know." },
    { unusual=true, id="scribe", name=_"Scribe", description=_"You can store your spells in scrolls, to be used later by other units.\nCreating a scroll costs the same as casting a spell, plus 5 mana for magical paper and ink. Activating a scroll only costs AP. You must choose all spell options except the target when you create the scroll. Ritual scrolls only take one turn to create; the unit that uses them is the one that takes more time." },
  },
  alliances = {
    { id="military_commander", name=_"Human military"    , description=_"You can recruit from the Loyalist faction, except Mages, plus Sergeants.\nYou gain Leadership and become Lawful.",
      recruit="Cavalryman,Horseman,Spearman,Fencer,Heavy Infantryman,Bowman,Sergeant,Merman Fighter" },
    { id="rascally_friends"  , name=_"Motley crew"       , description=_"You can recruit outlaws, including Ruffians and Pirate Galleons.\nYou gain Skirmisher.",
      recruit="Thief,Thug,Poacher,Footpad,Ruffian,Pirate Galleon" },
    { id="elvish_alliance"   , name=_"Elf-friend"        , description=_"You can recruit Elves and Merman Hunters.\nYou get 70% defense/1 move in forest.\nYou cures,heals +8.",
      recruit="Elvish Fighter,Elvish Archer,Elvish Scout,Elvish Shaman,Merman Hunter" },
    { id="dwarvish_alliance" , name=_"Dwarvish alliance" , description=_"You can recruit Dwarves, and if you can summon Gryphons, Gryphon Riders.\nYou get +20% physical resistances",
      recruit="Dwarvish Fighter,Dwarvish Thunderer,Dwarvish Guardsman,Dwarvish Ulfserker,Dwarvish Scout" },
    { id="orcish_mercenaries", name=_"Orcish mercenaries", description=_"You can recruit from the Northerners faction.\nYou get +2 melee damage.",
      recruit="Orcish Grunt,Troll Whelp,Wolf Rider,Orcish Archer,Orcish Assassin,Naga Fighter,Goblin Spearman" },
    { id="traveler"          , name=_"Traveler"          , description=_"You can recruit Young Ogres, Saurian Skirmishers, Peasants, Woodsmen, and Transport Galleons.\nYou get +1 move and improved terrain movement and defenses.",
      recruit="Young Ogre,Saurian Skirmisher,Woodsman,Peasant,Transport Galleon" },
    { id="petty_necromancer" , name=_"Petty necromancy"  , description=_"You can recruit from the Undead faction, except for Ghosts and Dark Adepts.\nYou become Chaotic, get +20% hitpoints, and gain plague on your staff.",
      recruit="Skeleton,Skeleton Archer,Walking Corpse,Vampire Bat,Ghoul" },
    w111 and { id="khalifate", name=_"Khalifate"         , description=_"You can recruit from the Khalifate faction.\nYou get 50% defense/1 move in desert.\nYou become Liminal, but get +20% damage on your attacks.",
      recruit="Jundi,Arif,Khaiyal,Rami,Hakim,Naffat,Falcon" } or nil,
  },
  perks = {},
  skill_ids = {},
}
local forbidden_to_liches = {}
local forbidden_to_apprentices = {}
EoHS.soon(function()
  if EoHS.no_alliances then
    EoHS.skills.alliances = {}
  end
  if EoHS.replace_alliances_with_era then
    EoHS.skills.alliances = {}
    for faction in helper.child_range(wesnoth.game_config.era, "multiplayer_side") do
      if faction.recruit and (faction.recruit ~= "") and not faction.random_faction then
        local legitimate = true
        for recruit in EoHS.comma_separated_values (faction.recruit) do
          if not wesnoth.unit_types [recruit] then legitimate = false end
        end
        if legitimate then
          table.insert(EoHS.skills.alliances, {
            id = "faction_"..faction.id,
            name = faction.name,
            description = EoHS.substitute(_"You can recruit from the $1| faction from $2|.", {faction.name, wesnoth.game_config.era.name}),
            recruit = faction.recruit,
          })
        end
      end
    end
  end

  for i,option in ipairs(EoHS.skills.options) do
    table.insert(EoHS.skills.perks, option)
    table.insert(EoHS.skills.skill_ids, option.id)
    forbidden_to_apprentices[option.id] = true
  end
  for i,talent in ipairs(EoHS.skills.talents) do
    table.insert(EoHS.skills.perks, talent)
    table.insert(EoHS.skills.skill_ids, talent.id)
    forbidden_to_apprentices[talent.id] = true
  end
  for i,alliance in ipairs(EoHS.skills.alliances) do
    table.insert(EoHS.skills.perks, alliance)
    table.insert(EoHS.skills.skill_ids, alliance.id)
    forbidden_to_apprentices[alliance.id] = true
    if (not EoHS.replace_alliances_with_era) and (alliance.id ~= "petty_necromancer") then forbidden_to_liches[alliance.id] = true end
  end
  for dummy,realm in ipairs(EoHS.skills.realms) do
    for i,rank in ipairs(realm.spells) do
      for j,spell_id in ipairs(rank) do
        table.insert(EoHS.skills.skill_ids, spell_id)
      end
    end
  end
end)
      
EoHS.nonspell_spell_skills = {
  --bigger_change_terrain = { name = "Expansive Change", description = _"Your Change Terrain spell can affect a much wider area." },
}
EoHS.spell_skill_name = function(spell_id)
  local a = EoHS.actions[spell_id]
  if a then return a.name end
  a = EoHS.nonspell_spell_skills[spell_id]
  if a then return a.name end
  return _"(unimplemented)"
end
EoHS.spell_skill_description = function(spell_id)
  local a = EoHS.actions[spell_id]
  if a then return a.description end
  a = EoHS.nonspell_spell_skills[spell_id]
  if a then return a.description end
  return ""
end

EoHS.unit_can_train = function(unit)
  return EoHS.get_unit_variable(unit, "is_wizard")
end
EoHS.soon(function() EoHS.unit_can_train_filter = EoHS.has_unit_variable("is_wizard") end)

EoHS.init_skillset = function(skillset)
  EoHS.copy_skillset({}, skillset)
end

EoHS.skillset_realm_rank = function(skillset, realm_id)
  local max_rank = 0
  local found_realm
  for dummy,realm in ipairs(EoHS.skills.realms) do
    if realm.id == realm_id then
      found_realm = true
      for i,rank in ipairs(realm.spells) do
        for j,spell_id in ipairs(rank) do
          if skillset[spell_id] then max_rank = i end
        end
      end
    end
  end
  EoHS.assert(found_realm, "EoHS.skillset_realm_rank called with no realm")
  return max_rank
end

EoHS.spells_known_from_skillset = function(skillset)
  local result = {}
  for dummy,realm in ipairs(EoHS.skills.realms) do
    for i,rank in ipairs(realm.spells) do
      for j,spell_id in ipairs(rank) do
        if skillset[spell_id] and EoHS.actions[spell_id] then table.insert(result,spell_id) end
      end
    end
  end
  return result
end

EoHS.points_needed_per_rank = function(skillset) return skillset.focused_study and 1 or 3 end
EoHS.points_to_learn_spell = function(rank_num) return (rank_num < 5) and 1 or 2 end

EoHS.skillset_points_spent = function(skillset)
  local result = 0
  local points_needed_per_rank = EoHS.points_needed_per_rank(skillset)
  local max_rank_in_any_realm = 0
  for dummy,realm in ipairs(EoHS.skills.realms) do
    local points_in_this_realm = 0
    for i,rank in ipairs(realm.spells) do
      for j,spell_id in ipairs(rank) do
        if skillset[spell_id] then
          --points_in_this_realm = math.max(points_in_this_realm, points_needed_per_rank * (i-1))
          points_in_this_realm = points_in_this_realm + EoHS.points_to_learn_spell(i)
          if i > max_rank_in_any_realm then max_rank_in_any_realm = i end
        end
      end
    end
    result = result + points_in_this_realm
  end
  if skillset.focused_study then result = result + max_rank_in_any_realm end
  local talents = 0
  for i,talent in ipairs(EoHS.skills.talents) do
    if skillset[talent.id] then
      talents = talents + 1
      result = result + talents
    end
  end
  local alliances = 0
  for i,alliance in ipairs(EoHS.skills.alliances) do
    if skillset[alliance.id] then
      result = result + alliances
      alliances = alliances + 1
    end
  end
  if not EoHS.replace_alliances_with_era then
    local living_alliances = alliances
    local has_necro_spell = (EoHS.skillset_realm_rank(skillset, "necromancy") >= 1)
    if skillset.petty_necromancer then
      living_alliances = living_alliances - 1
    end
    if living_alliances > 0 then
      if has_necro_spell then result = result + 1 end
    end
  end
  
  return result
end

EoHS.get_unit_skillset = function(unit)
  return EoHS.get_fake_subtag(EoHS.force_unit_variables(unit), "skillset")
end
EoHS.get_unit_skill = function(unit, name)
  return EoHS.get_unit_skillset(unit)[name]
end

EoHS.copy_skillset = function(src, dst)
  if not dst then dst = {} end
  for i,skill_id in ipairs(EoHS.skills.skill_ids) do
    dst[skill_id] = src[skill_id] or false
  end
  return dst
end
EoHS.skillsets_are_identical = function(s1,s2)
  for i,skill_id in ipairs(EoHS.skills.skill_ids) do
    if s1[skill_id] ~= s2[skill_id] then return false end
  end
  return true
end
EoHS.set_unit_skillset = function(unit, skillset)
  EoHS.copy_skillset(skillset, EoHS.get_unit_skillset(unit))
end
EoHS.train_unit_to_skillset = function(unit, skillset)
  EoHS.set_unit_skillset(unit, skillset)
  EoHS.update_all_type_adjustments(unit)
  EoHS.update_wizard_trait_desc(unit)
end

EoHS.unit_total_skill_points = function(unit)
  return EoHS.get_wizard_setting(unit, "skill_points_at_level_0") + EoHS.get_wizard_setting(unit, "skill_points_per_level") * unit.level
end
EoHS.unit_skill_points_left = function(unit)
  return EoHS.unit_total_skill_points(unit) - EoHS.skillset_points_spent(EoHS.get_unit_skillset(unit))
end

EoHS.choose_alliance_for_ai = function(unit)
  local skillset = EoHS.get_unit_skillset(unit)
  for i,alliance in ipairs(EoHS.skills.alliances) do
    if skillset[alliance.id] then
      return false
    end
  end
  if not EoHS.replace_alliances_with_era then
    -- with replacing alliances, we could
    -- skillset[EoHS.skills.alliances[EoHS.random("1.."..#EoHS.skills.alliances)].id] = true
    -- but everyone starts with an alliance in that mode anyway.
    skillset[EoHS.random("military_commander,rascally_friends,elvish_alliance,dwarvish_alliance,orcish_mercenaries,petty_necromancer")] = true
    EoHS.update_all_type_adjustments(unit)
    return true
  end
  return false
end

local amount_descriptions = {_"half",_"third",_"quarter"}
EoHS.update_wizard_trait_desc = function(unit)
  local trait = helper.get_child(helper.get_child(unit, "modifications"), "trait", "EoHS_wizard")
  local amount_description = amount_descriptions[math.min(unit.level+1, 3)]
  local skills_func = function()
    local skill_names = ""
    local add_name = function(name) skill_names = ((skill_names == "") and "" or skill_names..", ")..name end
    local skillset = EoHS.get_unit_skillset(unit)
    for i,option   in ipairs(EoHS.skills.options  ) do if skillset[  option.id] then add_name(  option.name) end end
    for i,talent   in ipairs(EoHS.skills.talents  ) do if skillset[  talent.id] then add_name(  talent.name) end end
    for i,alliance in ipairs(EoHS.skills.alliances) do if skillset[alliance.id] then add_name(alliance.name) end end
    for dummy,realm in ipairs(EoHS.skills.realms) do
      for i,rank in ipairs(realm.spells) do
        for j,spell_id in ipairs(rank) do
          if skillset[spell_id] then add_name(EoHS.spell_skill_name(spell_id)) end
        end
      end
    end
    trait.description = EoHS.substitute(_"This unit is immune to direct damage from spells, and it can only lose a $1| of its max hitpoints each time it's attacked. Beyond that, combat stops immediately.\n \nKnown skills: $2|\n \n", {amount_description, skill_names})
  end
  local no_skills_func = function()
    trait.description = EoHS.substitute(_"This unit is immune to direct damage from spells, and it can only lose a $1| of its max hitpoints each time it's attacked. Beyond that, combat stops immediately.\n \n", {amount_description})
  end
  EoHS.if_has_total_knowledge_of_side(unit.side, function()
    if EoHS.get_unit_variable(unit, "is_wizard") then
      skills_func()
    else
      no_skills_func()
    end
  end, no_skills_func)
end

local fill_prerequisites = function(skillset)
  local points_needed_per_rank = EoHS.points_needed_per_rank(skillset)
  for dummy,realm in ipairs(EoHS.skills.realms) do
    local max_rank = EoHS.skillset_realm_rank(skillset, realm.id)
    local points_in_earlier_ranks = 0
    for i,rank in ipairs(realm.spells) do
      if max_rank >= i then
        local gain_rank = i-1
        local gain_idx = 0
        local points_needed = points_needed_per_rank * (i-1)
        local lenience = 0
        while points_in_earlier_ranks < points_needed do
          gain_idx = gain_idx + 1
          if not realm.spells[gain_rank][gain_idx] then
            gain_rank = gain_rank - 1
            gain_idx = 1
          end
          if gain_rank <= 0 then
            if lenience > 100 then
              EoHS.err("some sort of issue with fill_prerequisites")
              return
            end
            gain_rank = i-1
            gain_idx = 1
            lenience = lenience + 1
          end
          local spell_id = realm.spells[gain_rank][gain_idx]
          EoHS.assert(spell_id, "some sort of issue with fill_prerequisites")
          if (not skillset[spell_id]) and (points_in_earlier_ranks + EoHS.points_to_learn_spell(gain_rank) <= points_needed + lenience) then
            skillset[spell_id] = true
            points_in_earlier_ranks = points_in_earlier_ranks + EoHS.points_to_learn_spell(gain_rank)
          end
        end
      end
      for j,spell_id in ipairs(rank) do
        if skillset[spell_id] then
          points_in_earlier_ranks = points_in_earlier_ranks + EoHS.points_to_learn_spell(i)
        end
      end
    end
  end
  if skillset.greater_mentor then skillset.mentor = true end
  if skillset.extra_apprentice_2 then skillset.extra_apprentice_1 = true end
  if skillset.extra_apprentice_1 then skillset.mentor = true end
end
local clear_postrequisites = function(skillset,minimal_skillset)
  local points_needed_per_rank = EoHS.points_needed_per_rank(skillset)
  for dummy,realm in ipairs(EoHS.skills.realms) do
    local points_in_earlier_ranks = 0
    for i,rank in ipairs(realm.spells) do
      local points_in_this_rank = 0
      for j,spell_id in ipairs(rank) do
        if skillset[spell_id] then
          if (points_in_earlier_ranks < points_needed_per_rank * (i-1)) and not minimal_skillset[spell_id] then
            skillset[spell_id] = false
          else
            points_in_this_rank = points_in_this_rank + EoHS.points_to_learn_spell(i)
          end
        end
      end
      points_in_earlier_ranks = points_in_earlier_ranks + points_in_this_rank
    end
  end
  if not skillset.mentor then
    skillset.greater_mentor = false
    skillset.extra_apprentice_1 = false
  end
  if not skillset.extra_apprentice_1 then
    skillset.extra_apprentice_2 = false
  end
  -- If there were things we were prevented from clearing, make sure their prerequisites weren't removed.
  fill_prerequisites(skillset)
end

local choose_one_random_skill = function(skillset, skill_points_limit, is_apprentice, is_lich)
  local choices = {}
  local has_spells = {}
  local points_needed_per_rank = EoHS.points_needed_per_rank(skillset)
  for z,realm in ipairs(EoHS.skills.realms) do
    for j,spell_id in ipairs(realm.spells[1]) do
      if skillset[spell_id] then
        has_spells[realm.id] = true
        has_spells.at_all = true
      end
    end
  end
  for z,realm in ipairs(EoHS.skills.realms) do
    local max_buyable_rank
    local points_in_this_realm = 0
    local unbought_spells = 0
    local rank_value = function(rank_num) return (rank_num == max_buyable_rank) and 20 or 1 end
    for i,rank in ipairs(realm.spells) do
      if points_in_this_realm < points_needed_per_rank * (i-1) then
        max_buyable_rank = i-1
        break
      end
      for j,spell_id in ipairs(rank) do
        if skillset[spell_id] then
          points_in_this_realm = points_in_this_realm + EoHS.points_to_learn_spell(i)
        end
      end
    end
    for i,rank in ipairs(realm.spells) do
      if points_in_this_realm < points_needed_per_rank * (i-1) then
        break
      end
      for j,spell_id in ipairs(rank) do
        if not skillset[spell_id] then
          unbought_spells = unbought_spells + rank_value(i)
        end
      end
    end
    for i,rank in ipairs(realm.spells) do
      if points_in_this_realm < points_needed_per_rank * (i-1) then
        break
      end
      local weight
      if not has_spells.at_all then weight = 10000000*rank_value(i)/unbought_spells -- Pick a spell already! But have equal chances of picking each realm.
      elseif not has_spells[realm.id] then weight = 750*rank_value(i)/unbought_spells -- not likely to branch into another realm
      else weight = math.ceil(100000*rank_value(i)/unbought_spells) end -- A new spell in a realm we already have: Good.
                                                                        -- And have the same probability of taking one regardless of how many there are.
                                                                        -- With rank_value, we prefer getting max level spells.
      for j,spell_id in ipairs(rank) do if not skillset[spell_id] then
        table.insert(choices, { skill = spell_id, weight = weight, realm = realm.id })
      end end
    end
  end
  
  local talents = 0
  for i,talent in ipairs(EoHS.skills.talents) do if skillset[talent.id] then
    talents = talents + 1
  end  end
  for i,talent in ipairs(EoHS.skills.talents) do if not skillset[talent.id] then
    if skillset.show_unusual or not talent.unusual then table.insert(choices, { skill = talent.id, weight = math.ceil(4000 / math.max(1,talents*2)) }) end
  end end
  local alliances = 0
  for i,alliance in ipairs(EoHS.skills.alliances) do if skillset[alliance.id] then
    alliances = alliances + 1
  end end
  for i,alliance in ipairs(EoHS.skills.alliances) do if not skillset[alliance.id] then
    if skillset.show_unusual or not alliance.unusual then table.insert(choices, { skill = alliance.id, weight = math.ceil(4000 / (1+(alliances*alliances*20))), living_alliance = (alliance.id ~= "petty_necromancer") }) end
  end end
  local living_alliances = alliances
  if skillset.petty_necromancer then
    living_alliances = living_alliances - 1
  end
  
  local filtered_choices = {}
  local weight_total = 0
  for i,choice in ipairs(choices) do
    local can_pick = true
    if is_apprentice and forbidden_to_apprentices[choice.skill] then can_pick = false end
    if is_lich and forbidden_to_liches[choice.skill] then can_pick = false end
    if skill_points_limit then
      local next_skillset = EoHS.copy_skillset(skillset)
      next_skillset[choice.skill] = true
      fill_prerequisites(next_skillset)
      if EoHS.skillset_points_spent(next_skillset) > skill_points_limit then
        can_pick = false
      end
    end
    if can_pick then
      if not EoHS.replace_alliances_with_era then
        if has_spells.necromancy and choice.living_alliance then choice.weight = math.ceil(choice.weight / 20) end
        if (choice.realm == "necromancy") and (not has_spells.necromancy) and (living_alliances > 0) then choice.weight = math.ceil(choice.weight / 10) end
      end
      table.insert(filtered_choices, choice)
      weight_total = weight_total + choice.weight
    end
  end
  
  if not filtered_choices[1] then return false end
  local pick = math.random(1,weight_total)
  for i,choice in ipairs(filtered_choices) do
    pick = pick - choice.weight
    if pick <= 0 then
      skillset[choice.skill] = true
      return true
    end
  end
  return false
end

EoHS.training_dialog_grid = function(dialog_context, unit, minimal_skillset, minimal_skillsets_of_same_side_wizards, variant)
  local total_points = EoHS.unit_total_skill_points(unit)
  local skillset = EoHS.get_unit_skillset(unit)
  local is_apprentice = EoHS.get_unit_variable(unit, "is_apprentice")
  local is_lich = EoHS.get_unit_variable(unit, "is_lich")
  local g = function(contents) return { "grid", contents } end
  local r = function(contents) return { "row", contents } end
  local c = function(contents) return { "column", contents } end
  local l = function(text) return { "label", { definition = "default_small", label = text } } end
  local title = function(text) return { "label", { label = text, definition = "title" } } end
  local t = function(id) return { "text_box", { id = id } } end
  local orb_crop = "~CROP(16,0,9,11)"
  local ok_orb = (w111 and "misc/orb.png~RC(magenta>brightgreen)" or "misc/orb-unmoved.png")..orb_crop
  local bad_orb = (w111 and "misc/orb.png~RC(magenta>red)" or "misc/orb-moved.png")..orb_crop
  local no_orb = "misc/orb-enemy.png"..orb_crop
  
  local can_possibly_afford = function(skill)
    local next_skillset = EoHS.copy_skillset(minimal_skillset)
    -- Hack - use your current options, except for if skill is an option
    for i,option in ipairs(EoHS.skills.options) do
      next_skillset[option.id] = skillset[option.id]
    end
    next_skillset[skill] = not skillset[skill]
    fill_prerequisites(next_skillset)
    if EoHS.skillset_points_spent(next_skillset) > total_points then
      return false
    end
    return true
  end
  
  local skill_points_remaining_string = _"Skill points remaining:"
  local update_total_points = function()
    local remaining_points = total_points - EoHS.skillset_points_spent(skillset)
    wesnoth.set_dialog_value(""..(total_points - EoHS.skillset_points_spent(minimal_skillset)), "total_points_box")
    --wesnoth.set_dialog_active(remaining_points >= 0, "ok")
    wesnoth.set_dialog_value(""..remaining_points, "points_remaining_box")
    -- I don't at all understand this dance of resetting and concatenating values,
    -- but if I remove any part of it, the result is visible incorrect behavior...
    wesnoth.set_dialog_value(skill_points_remaining_string..remaining_points, "points_remaining_label")
    wesnoth.set_dialog_value(skill_points_remaining_string, "points_remaining_label")
    wesnoth.set_dialog_canvas(1, { {"text",{
      x = "0", y = "0", w = "(text_width)", h = "(text_height)",
      font_size = EoHS.macros.GUI_NORMAL__FONT_SIZE__LARGE,
      color = EoHS.dialog_color (EoHS.validity_color(remaining_points >= 0)),
      text = skill_points_remaining_string.."",
    }} }, "points_remaining_label")
    wesnoth.set_dialog_canvas(1, { {"text",{
      x = "0", y = "0", w = "(text_width)", h = "(text_height)",
      font_size = EoHS.macros.GUI_NORMAL__FONT_SIZE__LARGE,
      color = EoHS.dialog_color (EoHS.validity_color(remaining_points >= 0)),
      text = ""..remaining_points,
    }} }, "points_remaining_box")
  end
  
  -- Focused Study can be unlearned, but nothing else can
  local is_stuck_on = function(skill_id) return minimal_skillset[skill_id] and (skill_id ~= "focused_study") end
  local should_be_enabled = function(skill_id)
    if is_apprentice and forbidden_to_apprentices[skill_id] then return false end
    if is_apprentice then
      local allowed = false
      for i,s in ipairs(minimal_skillsets_of_same_side_wizards) do
        if s.mentor and s[skill_id] then allowed = true end
        if s.greater_mentor then allowed = true end
      end
      if not allowed then return false end
    end
    if is_lich and forbidden_to_liches[skill_id] then return false end
    if is_stuck_on(skill_id) then return false end
    if skill_id == "mentor" and not EoHS.get_wizard_setting(unit, "can_recruit") then return false end
    if skill_id == "scribe" and EoHS.get_wizard_setting(unit, "mana_capacity_per_level") ~= "infinite" then return false end
    return can_possibly_afford(skill_id)
  end
  
  local update_all
  local perk_update = function(perk)
    return function()
      local id = perk.id.."_toggle"
      if not should_be_enabled(perk.id) then wesnoth.set_dialog_value(skillset[perk.id], id); return end
      skillset[perk.id] = wesnoth.get_dialog_value(id)
      if skillset[perk.id] then
        fill_prerequisites(skillset)
      else
        clear_postrequisites(skillset,minimal_skillset)
      end
      update_all()
    end
  end
  update_all = function()
    local unusual_skills = false
    local points_needed_per_rank = EoHS.points_needed_per_rank(skillset)
    for i,perk in ipairs(EoHS.skills.perks) do
      if skillset.show_unusual or not perk.unusual then
        if skillset[perk.id] and perk.unusual then unusual_skills = true end
        if not perk.fake_toggle_button then
          wesnoth.set_dialog_callback(perk_update(perk), perk.id.."_toggle")
          wesnoth.set_dialog_value(skillset[perk.id], perk.id.."_toggle")
          EoHS.fake_set_toggle_button_active(should_be_enabled(perk.id), perk.id.."_toggle")
        end
      end
    end
    for dummy,realm in ipairs(EoHS.skills.realms) do
      local counter = 0
      for i,rank in ipairs(realm.spells) do
        for o=1,3 do
          local orb_id = realm.id.."_"..i.."_orb_"..o
          if (i==1) or (o>points_needed_per_rank) then wesnoth.set_dialog_value(no_orb, orb_id)
          else
            wesnoth.set_dialog_value((counter>0) and ok_orb or bad_orb, orb_id)
            counter = counter - 1
          end
        end
        for j,spell_id in ipairs(rank) do
          wesnoth.set_dialog_value(skillset[spell_id], spell_id.."_toggle")
          --local image = EoHS.actions[spell_id] and EoHS.actions[spell_id].image.."~CROP(5,5,50,50)"
          EoHS.fake_set_toggle_button_active(should_be_enabled(spell_id), spell_id.."_toggle"--[[, image]])
          if skillset[spell_id] then counter = counter + EoHS.points_to_learn_spell(i) end
        end
      end
    end
    wesnoth.set_dialog_active(not unusual_skills, "show_unusual_toggle")
    update_total_points()
  end

  local summary_grid = g{
    r{
      c{ horizontal_alignment="right", { "label", { definition = "default_large", label = _"Skill points to spend:"}}},
      c{ horizontal_grow=true, border="left", border_size=8, grow_factor=2, { "label", { definition = "default_large", id = "total_points_box" } }}
    },
    r{
      c{ horizontal_alignment="right", { "label", { definition = "default_large", id = "points_remaining_label", label = skill_points_remaining_string}}},
      c{ horizontal_grow=true, border="left", border_size=8, { "label", { definition = "default_large", id = "points_remaining_box" } }}}
  }
  
  local realms_rows = {r{c{border="left,right", border_size=15, g{r{c{horizontal_alignment="left", title(_"Spells")}},r{c{border="all", border_size=5,
    l(_"Each spell costs one skill point.\nTo learn a spell, you must first spend three points per lower rank in the same realm.\n \nEach realm gives you a ranged attack and a resistance bonus,\nbased on your level or highest spell rank, whichever is less.")}}}}}}
  
  dialog_context.add_top_level({"linked_group",{id = "realm_box", fixed_width = true}})
  local realms_cols_1 = {}
  local realms_cols_2 = {}
  for dummy,realm in ipairs(EoHS.skills.realms) do
    local realm_rows_1 = {
      linked_group = "realm_box",
      r{c{title(realm.names.realm)}},
    }
    local realm_rows_2 = {
      linked_group = "realm_box",
    }
    
    for i,rank in ipairs(realm.spells) do
      local realm_rows = (i<5) and realm_rows_1 or realm_rows_2
      local rank_header_cols = {}
      for o=1,3 do table.insert(rank_header_cols,c{{"image",{label=no_orb,id=realm.id.."_"..i.."_orb_"..o}}}) end
      table.insert(rank_header_cols,c{ border="top,left", border_size=5, l(EoHS.substitute(_"Rank $1|",{i})) })
      table.insert(realm_rows, r{c{g{r(rank_header_cols)}}})
      for j,spell_id in ipairs(rank) do
        local id = spell_id.."_toggle"
        local name = EoHS.spell_skill_name(spell_id)
        local description = EoHS.spell_skill_description(spell_id)
        table.insert(realm_rows, r{c{ horizontal_alignment="left",
          EoHS.toggle_button(
            dialog_context,
            {id=id,label=name,tooltip=name.."\n\n"..description})
        }})
  
        dialog_context.preshow(function()
          wesnoth.set_dialog_callback(function()
            if not should_be_enabled(spell_id) then wesnoth.set_dialog_value(skillset[spell_id], id); return end
            skillset[spell_id] = wesnoth.get_dialog_value(id)
            if skillset[spell_id] then
              fill_prerequisites(skillset)
            else
              clear_postrequisites(skillset,minimal_skillset)
            end
            update_all()
          end, id)
        end)
      end
    end
    table.insert(realms_cols_1, c{border="top,left,right", border_size=9, vertical_alignment="top", g(realm_rows_1)})
    table.insert(realms_cols_2, c{border="bottom,left,right", border_size=9, vertical_alignment="top", g(realm_rows_2)})
  end
  table.insert(realms_rows, r{c{g{r(realms_cols_1)}}})
  table.insert(realms_rows, r{c{horizontal_alignment="left", border="left,right,top", border_size=15,
    l(_"Rank 5+ spells cost two skill points.")}})
  table.insert(realms_rows, r{c{g{r(realms_cols_2)}}})
  local realms_grid = g(realms_rows) --{"scrollbar_panel",{{"definition",realms_rows}}}
  
  
  local perk_toggle = function(perk)
    local id = perk.id.."_toggle"
    local contents = {id=id,label=perk.name,tooltip=perk.name.."\n\n"..perk.description}
    if perk.fake_toggle_button then
      if perk.id == "focused_study" then dialog_context.preshow(function() wesnoth.set_dialog_active(should_be_enabled("focused_study"), id) end) end
      return EoHS.fake_toggle_button(dialog_context, contents, skillset[perk.id], function()
        skillset[perk.id] = not skillset[perk.id]
        if (perk.id == "focused_study") and not skillset.focused_study then
          clear_postrequisites(skillset,minimal_skillset)
        end
      end)
    else
      return EoHS.toggle_button(dialog_context, contents)
    end
  end
  
  local options_rows = {r{c{horizontal_alignment="left", border="bottom", border_size=5, title(_"Options")}},}
  for i,option in ipairs(EoHS.skills.options) do
    if skillset.show_unusual or not option.unusual then table.insert(options_rows, r{c{horizontal_alignment="left", perk_toggle(option)}}) end
  end
  
  local talents_rows = {r{c{horizontal_alignment="left", title(_"Talents")}},r{c{border="all", border_size=5, l(_"Buying a talent costs one point,\nplus one for each talent you already have.")}}}
  for i,talent in ipairs(EoHS.skills.talents) do
    if skillset.show_unusual or not talent.unusual then table.insert(talents_rows, r{c{horizontal_alignment="left", perk_toggle(talent)}}) end
  end
  
  local alliances_rows = {
    r{c{horizontal_alignment="left", title(_"Recruits")}},
    r{c{border="all", border_size=5, l(_"Your first alliance is free. Later alliances cost\none point for each alliance you already have." .. (EoHS.replace_alliances_with_era and "" or _"\nYou pay one extra if you have a Necromancy\nspell and take one or more living alliances."))}}}
  for i,alliance in ipairs(EoHS.skills.alliances) do
    if skillset.show_unusual or not alliance.unusual then table.insert(alliances_rows, r{c{horizontal_alignment="left", perk_toggle(alliance)}}) end
  end
  
  local reset = function()
    local show_unusual = skillset.show_unusual
    EoHS.deep_overwrite(skillset, minimal_skillset)
    skillset.show_unusual = show_unusual
  end
  
  local buttons_rows = {
    r{c{g{
      r{c{ dialog_context.button({label = _"Reset skills"}, reset) },
      c{ dialog_context.button({label = _"Random skills"}, function()
        reset()
        while choose_one_random_skill(skillset, total_points, is_apprentice, is_lich) do end
      end) }},
    }}},
    --r{c{ {"button",{label = _"Finish training", id="ok"}} }},
  }
  if EoHS.appearance_is_customizable(unit) then
    table.insert(buttons_rows, r{c{ dialog_context.button({label = _"Change appearance"}, function()
      if EoHS.show_dress_up_dialog(unit) then
        EoHS.update_unit_graphics(unit)
      end
    end) }})
  end
  --[[if variant == "preselect" then
    table.insert(buttons_rows, r{c{
      l(_"Choices will be applied at\nthe beginning of your next turn.")
    }})
  end]]
  local buttons_grid = g(buttons_rows)
  
  local perks_grid = g{
    r{c{ horizontal_alignment="left", border="all", border_size=7, g(  talents_rows) }},
    r{c{ horizontal_alignment="left", border="all", border_size=7, g(  options_rows) }},
    r{c{ horizontal_grow     = true , border="all", border_size=7, summary_grid }},
    r{c{                              border="all", border_size=7, buttons_grid }},
  }
  table.insert (perks_grid[2], EoHS.skills.alliances [12] and 5 or 1,
    r{c{ horizontal_alignment="left", border="all", border_size=7, g(alliances_rows) }}
  )
  
  dialog_context.preshow(update_all)

  return g{r{c{vertical_alignment="top", perks_grid},c{vertical_alignment="top", border="top,right", border_size=7, realms_grid}}}
end

local premade_skillsets = {
  evocation = {
    alliance = "military_commander",
    spells = {"energy_blast", "wizard_sword", "mage_shield", "summon_fire_guardian", "corridor_of_frost", "summon_arctic_drake", "fireball", "group_teleport", "summon_sea_serpent", "circle_of_protection", "haste",},
  },
  nature_magic = {
    alliance = "dwarvish_alliance",
    spells = {"summon_wolf", "restraint", "summon_giant_scorpion", "change_terrain", "mount", "regeneration", "summon_wose", "summon_water_serpent", "lightning_bolt", "metamorphosis", "summon_gryphon",},
  },
  necromancy = {
    alliance = "petty_necromancer",
    spells = {"curse_of_anxiety", "summon_vampire_bat", "pall_of_fatigue", "summon_skeleton", "siphon_strength", "summon_ghost", "zombie_swarm", "reanimating_touch", "spiritform", "dark_pact", "soul_bind",},
  },
}

local sides_investigated_for_initial_choice = {}
EoHS.maybe_choose_premade_skills = function(options)
  options = options or {}
  if wesnoth.current.turn == 1 and EoHS.get_variable ("settings_inited") then
    for side, info in ipairs (wesnoth.sides) do
      if wesnoth.current.side <= side and info.controller == "human" and not sides_investigated_for_initial_choice[side] then
        sides_investigated_for_initial_choice[side] = true
        local wizards = EoHS.get_units ({side = side, EoHS.has_unit_variable ("is_wizard")})
        if #wizards == 1 then
          local wizard = wizards [1]
          local skills = EoHS.get_unit_skillset(wizard)
          local unskilled = true
          for i,skill_id in ipairs(EoHS.skills.skill_ids) do
            if skills[skill_id] then
              unskilled = false
              break
            end
          end
          if unskilled then
            local choices = {
              {id="evocation",label =_"A fireball-throwing Evoker", image = "attacks/fireball.png"},
              {id="nature_magic",label =_"A subtle Nature wizard", image = "attacks/entangle.png"},
              {id="necromancy",label =_"A selfish Necromancer", image = "attacks/staff-necromantic.png"},
              {id="custom",label =_"Let me customize my skills", image = "units/unknown-unit.png"},
            }

            local choice = EoHS.choose_in_dialog (choices, {heading_label = _"Welcome to Era of High Sorcery (EoHS)!\nWhat kind of wizard would you like to be?"})
                        if choice.id == "custom" then
              if not options.interrupting_menu then
                -- can't do this, it crashes the game
                --EoHS.menu_item_invoked()
                -- Whoops, this crashes the game as well
                EoHS.menu_item_invoked_inner()
              end
            else
              local points = EoHS.unit_total_skill_points (wizard)
              local premade = premade_skillsets [choice.id]
              skills [premade.alliance] = true
              for index, spell in ipairs (premade.spells) do
                if points >= index then
                  skills [spell] = true
                end
              end
              local training = EoHS.copy_skillset (skills)
              training.trainer_id = EoHS.unit_id (wizard)
              local choices = {{"training", training}}
              if side ~= wesnoth.current.side or options.interrupting_menu then
                EoHS.do_off_turn_menu_results(choices)
              else
                EoHS.do_synced_soon ("do_menu_results", choices)
              end
            end
            return
          end
        end
      end
    end
  end
end

-->>)}
